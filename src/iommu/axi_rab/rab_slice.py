# // Copyright 2018 ETH Zurich and University of Bologna.
# // Copyright and related rights are licensed under the Solderpad Hardware
# // License, Version 0.51 (the "License"); you may not use this file except in
# // compliance with the License.  You may obtain a copy of the License at
# // http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
# // or agreed to in writing, software, hardware and materials distributed under
# // this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
# // CONDITIONS OF ANY KIND, either express or implied. See the License for the
# // specific language governing permissions and limitations under the License.
#
# module rab_slice
# #(
#    parameter ADDR_WIDTH_PHYS = 40,
#    parameter ADDR_WIDTH_VIRT = 32
#    )
#   (
#    input  logic [ADDR_WIDTH_VIRT-1:0] cfg_min,
#    input  logic [ADDR_WIDTH_VIRT-1:0] cfg_max,
#    input  logic [ADDR_WIDTH_PHYS-1:0] cfg_offset,
#    input  logic                       cfg_wen,
#    input  logic                       cfg_ren,
#    input  logic                       cfg_en,
#    input  logic                       in_trans_type,
#    input  logic [ADDR_WIDTH_VIRT-1:0] in_addr_min,
#    input  logic [ADDR_WIDTH_VIRT-1:0] in_addr_max,
#    output logic                       out_hit,
#    output logic                       out_prot,
#    output logic [ADDR_WIDTH_PHYS-1:0] out_addr
#  );
# this file has been generated by sv2nmigen

from nmigen import Signal, Module, Const, Cat, Elaboratable


class rab_slice(Elaboratable):

    def __init__(self, params):  # pass config object
        # TODO parameters
        self.params = params
        self.cfg_min = Signal(params.ADDR_WIDTH_VIRT)  # input
        self.cfg_max = Signal(params.ADDR_WIDTH_VIRT)  # input
        self.cfg_offset = Signal(params.ADDR_WIDTH_PHYS)  # input
        self.cfg_wen = Signal()  # input
        self.cfg_ren = Signal()  # input
        self.cfg_en = Signal()  # input
        self.in_trans_type = Signal()  # input
        self.in_addr_min = Signal(params.ADDR_WIDTH_VIRT)  # input
        self.in_addr_max = Signal(params.ADDR_WIDTH_VIRT)  # input
        self.out_hit = Signal()  # output
        self.out_prot = Signal()  # output
        self.out_addr = Signal(params.ADDR_WIDTH_PHYS)  # output

    def elaborate(self, platform=None):
        m = Module()
        min_above_min = Signal()
        min_below_max = Signal()
        max_below_max = Signal()

        #  assign min_above_min = (in_addr_min >= cfg_min) ? 1'b1 : 1'b0;
        #  assign min_below_max = (in_addr_min <= cfg_max) ? 1'b1 : 1'b0;
        #  assign max_below_max = (in_addr_max <= cfg_max) ? 1'b1 : 1'b0;
        #  assign out_hit  = cfg_en & min_above_min & min_below_max & max_below_max;
        #  assign out_prot = out_hit & ((in_trans_type & ~cfg_wen) | (~in_trans_type & ~cfg_ren));
        #  assign out_addr = in_addr_min - cfg_min + cfg_offset;
        m.d.comb += [
            min_above_min.eq(self.in_addr_min >= self.cfg_min),
            min_below_max.eq(self.in_addr_min <= self.cfg_max),
            max_below_max.eq(self.in_addr_max <= self.cfg_max),
            self.out_hit.eq(self.cfg_en & min_above_min &
                            min_below_max & max_below_max),
            self.out_prot.eq(self.out_hit & (
                (self.in_trans_type & ~self.cfg_wen) | (~self.in_trans_type & ~self.cfg_ren))),
            self.out_addr.eq(self.in_addr_min - self.cfg_min + self.cfg_offset)
        ]

        return m
